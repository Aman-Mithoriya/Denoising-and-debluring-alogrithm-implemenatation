# -*- coding: utf-8 -*-
"""signal and system.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1auPYiCalg2pHRKy2NXbAu5kBwVxAkU7I
"""

# importing library
import pandas as pd
import numpy as np
from scipy.fftpack import fft, ifft
import matplotlib.pyplot as plt
import statistics

# extracting file:
data_file = pd.read_csv('data.csv')
y = data_file['y[n]'].values
x = data_file['x[n]'].values
#print(y)

# given data
h=[1/16,4/16,6/16,4/16,1/16]

    
def de_noise(y):   #definning the function to denoise a signal
  y_denoise=[] #creating empty list where we are appending denoised signal 
  for i in range(1,1+len(y)):# range from which is started from 1 rather than 0 to avoid division by zero error
    x=i+1
    
    y_denoise.append(sum(y[x:x+193])/193)# in this step we were appending denoised signal in list called de_noise we have found that denoised by taking avg of all signals before that signal
  return y_denoise #just returning the denoised list as output
# print(y_denoise)


def de_blur(m):
    Y = np.array(fft(m))#defining fourier transform of input signal
    H= np.array(fft(h))#fourier transform of given impulse of blurrig
    h1 = []
    for i in H:
        h1.append(1/i)#as we know h(jw)h'(jw)=1 so we are taking inverse of blur signal
    Deblured = []
    for i in Y:
        c=0
        for j in H:
            c= c+(i*j)#taking convolute with fourier signal
        Deblured.append(c)
        c=0
    deblured_signal = ifft(Deblured)#converting fourier to back discrete signal
    return(abs(deblured_signal))
    
#driver code 
# x1[n] =h1[n]*[y[n]+denoise]
zipped_l = zip(y,de_noise(y))
x1 =[i+j for (i,j)in zipped_l]
x1= de_blur(y+de_noise(y))
print('x1[n]:',x1)

# x2[n] = h1[n]*y[n]+denoise
c = list(de_blur(y))
d = list(de_noise(y))
zipped_li = zip(c,d)
x2 = [i+j for (i ,j) in zipped_li]
print('x2[n]:',x2)

#driver code 
# x1[n] =h1[n]*[y[n]+denoise]
zipped_l = zip(y,de_noise(y))
x1 =[i+j for (i,j)in zipped_l]
x1= de_blur(y+de_noise(y))
print('x1[n]:',x1)

# x2[n] = h1[n]*y[n]+denoise
c = list(de_blur(y))
d = list(de_noise(y))
zipped_li = zip(c,d)
x2 = [i+j for (i ,j) in zipped_li]
print('x2[n]:',x2)



n=[ i for i  in range(193)]
plt.scatter(n,x1,color='hotpink')
plt.scatter(n,x)

plt.scatter(n,x2,color='#88c999')


print("Standard Deviation of sample is % s "% (statistics.stdev(x)))
print("Standard Deviation of sample is % s "% (statistics.stdev(x1)))
print("Standard Deviation of sample is % s "% (statistics.stdev(x2)))

#driver code 
# x1[n] =h1[n]*[y[n]+denoise]
zipped_l = zip(y,de_noise(y))
x1 =[i+j for (i,j)in zipped_l]
x1= de_blur(y+de_noise(y))
print('x1[n]:',x1)

# x2[n] = h1[n]*y[n]+denoise
c = list(de_blur(y))
d = list(de_noise(y))
zipped_li = zip(c,d)
x2 = [i+j for (i ,j) in zipped_li]
print('x2[n]:',x2)